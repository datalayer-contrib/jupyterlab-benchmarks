# Profiling

We invite you reading the [anatomy of a frame](https://aerotwist.com/blog/the-anatomy-of-a-frame/) to understand this figure (taken from a download of [this zip file](https://aerotwist.com/static/blog/the-anatomy-of-a-frame/anatomy-of-a-frame.zip)).

![](images/anatomy-of-a-frame.svg "")

## TLDR

JupyterLab is hanging out / iterating at the Recalc style / Layout steps and does not produce the needed Tiles to be displayed. This happens when ["Any CSS property that changes an element's geometry, like its width, height, or position; the browser has to check all other elements and redo the layout.."](https://developers.google.com/web/tools/chrome-devtools/rendering-tools#layout).

From the many cells profiling, the Force layout is triggered in codemirror.

The single cell profiling does not highlight the code mirror issue: jupyterlab is nearly as performant as classic notebook as we test with only one cell editor.

## Fix Options

We can think to adhoc fixes. One way to get adhoc fix would be to further look at `updateEditorOnShow` implemented in [jupyterlab/jupyterlab#5700](https://github.com/jupyterlab/jupyterlab/issues/5700), but [is is already set to false...](https://github.com/jupyterlab/jupyterlab/blob/71f07379b184d5b0b8b67b55163d27194a61a0ac/packages/notebook/src/widget.ts#L493).

We can also think to more generic fixes like using [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).

## Open vs Switch Tab

The following analysis have been done when opening a notebook. When you switch to an already opened tab, the DOM is already populated and simple hidden with `lm-mod-hidden` and `p-mod-hidden` CSS classes. So when the browser needs to show it again, the cost preliminary steps are not run (so no Forced layout), and the cost is "just": "Recalc Style"->"Layout" all the way down to the Painting and Rasterizing without iteration

##  Many Cells - 2 LOC and 2 outputs per cell with 250 cells

> JupyterLab

![](images/profiles/89726263-e12b4100-da18-11ea-95cf-d7eb0821c10b.png "")

`fromJSON` (10s) with iteration via pushAll on push->_onOrderChanged->onCellsChanged->each->_insertCell

`setOption` (10s) (`void Mode.ensure(mime).then(spec => { editor.setOption('mode', spec?.mime ?? 'null'); });`) with a lot of repetitive Forced reflow generated by codemirror.js (see next image).

![](images/profiles/89726287-218abf00-da19-11ea-8e5b-41a8f19db3d9.png "")

`@lumino/messaging` `runMessageLoop` (13s), for which the initiator is at the very beginning (second 0), also with a lot of Forced reflow  (see next image).

![](images/profiles/89726303-42531480-da19-11ea-9201-a477e8a33ee0.png "")

> Classic Notebook

![](images/profiles/89726806-03c05880-da1f-11ea-82fb-f267f4e6e9e4.png "")

`Notebook.load_notebook_success `(19.2s) calling Notebook.fromJSON iterating on Notebook.insert_cell_at_index

There are some Forced reflow but less than in lab. They are triggered by codemirror (e.g. `removeChildrenAndAdd(display.measure, measureText); var height = measureText.offsetHeight / 50;`) (see next image).

![](images/profiles/89726327-96f68f80-da19-11ea-90f4-1c6d8b1a3bb7.png "")

Notebook is displayed and a few more quick actions are taken Notebook _session_started (0.3s)

> Comparison

NbClassic takes 20s to load the notebook and suffers from Forced reflow.

JupyterLab takes 33s to load and is more impacted by the Forced reflow than NbClassic is. Those Forced reflow are repetitive.

It sounds like most of the latency is due to codemirror triggering reflows. I will look a bit how to typically solve this, see e.g. [CodeMirror/#/5873](https://github.com/codemirror/CodeMirror/issues/5873).

## Single Cell - 1 cell with many DIV outputs

> JupyterLab

![](images/profiles/89727264-3a986d80-da23-11ea-9ac7-bd0aa5f68484.png "")

`notebook.model.fromJson` (7s): A first action results appending the many div outputs without Forced layout (5s) followed by a Force layout in codemirror (2s) (in `measureCharInner`).

![](images/profiles/89726966-f015f180-da20-11ea-970f-c89c7cdfe469.png "")

Style is Forced recalculated (1.72s) triggered by codemirror further to some lumino messages (note the 0.3s Update tree before and after this)

> Classic Notebook

![](images/profiles/89726994-3ec38b80-da21-11ea-960b-4891cddbcff6.png "")

`Notebook.load_notebook_success` (18s) calling `Notebook.fromJSON`->`OutputArea.fromJSON`.

![](images/profiles/89727132-6404c980-da22-11ea-9566-a803f7c8b571.png "")

Then 0.5s to recalculate the styles and layout.

PS: When profiling, classic notebook opens slower than without profiling, which can be understandable and is not an issue as we want to spot here the bottlenecks.

> Comparison

JupyterLab is here 20% slower than Classic Notebook.

## Quick Fix Attempt 1 - Use requestAnimationFrame (non concluding)

Wrapped the cell creation into a requestAnimationFrame call. This produces a different profile pattern (2 heavy sections separated by an inactive one). The Forced layout due to codemirror are still there.

![](images/profiles/89731086-9d4e3100-da44-11ea-9e2b-292f8a14920c.png "")

```javascript
requestAnimationFrame(() => {
    const cellDB = this._factory.modelDB!;
    const cellType = cellDB.createValue(id + '.type');
    let cell: ICellModel;
    switch (cellType.get()) {
        case 'code':
        cell = this._factory.createCodeCell({ id: id });
        break;
        case 'markdown':
        cell = this._factory.createMarkdownCell({ id: id });
        break;
        default:
        cell = this._factory.createRawCell({ id: id });
        break;
    }
    this._cellMap.set(id, cell);
});
```
